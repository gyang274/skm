# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' dist_wlatlng_mi_cpp: dist between coordinate1<lat1, lng1> and coordinate2<lat2, lng2> in mile
dist_wlatlng_mi_cpp <- function(lat1, lng1, lat2, lng2) {
    .Call('skm_dist_wlatlng_mi_cpp', PACKAGE = 'skm', lat1, lng1, lat2, lng2)
}

#' dist_wlatlng_mi_cpp: dist between coordinate1<lat1, lng1> and coordinate2<lat2, lng2> in kilometer
dist_wlatlng_km_cpp <- function(lat1, lng1, lat2, lng2) {
    .Call('skm_dist_wlatlng_km_cpp', PACKAGE = 'skm', lat1, lng1, lat2, lng2)
}

distSgl_wlatlng_cpp <- function(lat1, lng1, lat2, lng2, measure = "mi") {
    .Call('skm_distSgl_wlatlng_cpp', PACKAGE = 'skm', lat1, lng1, lat2, lng2, measure)
}

distRpl_wlatlng_cpp <- function(lat1, lng1, lat2, lng2, measure = "mi", distRpl_GS = 100L) {
    .Call('skm_distRpl_wlatlng_cpp', PACKAGE = 'skm', lat1, lng1, lat2, lng2, measure, distRpl_GS)
}

#' col_min_idx: colvec min value index within limited range
#' @param wlmt: a limit search on colvec on indices within wlmt
#' @return return an index of min value w.r.t to original index
#' @note cpp use index start from 0 vs r use index start from 1
#' @note in case of equal std:min/std:max take first index seen
col_min_idx <- function(u, wlmt) {
    .Call('skm_col_min_idx', PACKAGE = 'skm', u, wlmt)
}

#' col_max_idx: colvec max value index within limited range
#' @param wlmt: a limit search on colvec on indices within wlmt
#' @return return an index of max value w.r.t to original index
#' @note cpp use index start from 0 vs r use index start from 1
#' @note in case of equal std:min/std:max take first index seen
col_max_idx <- function(u, wlmt) {
    .Call('skm_col_max_idx', PACKAGE = 'skm', u, wlmt)
}

#' col_min_val: colvec min value within limited range
col_min_val <- function(u, wlmt) {
    .Call('skm_col_min_val', PACKAGE = 'skm', u, wlmt)
}

#' col_max_val: colvec max value within limited range
col_max_val <- function(u, wlmt) {
    .Call('skm_col_max_val', PACKAGE = 'skm', u, wlmt)
}

#' col_rgn_val: colvec range = max - min value within limited range
col_rgn_val <- function(u, wlmt) {
    .Call('skm_col_rgn_val', PACKAGE = 'skm', u, wlmt)
}

skm_mlp_cpp <- function(x, k, s_must, max_it, max_at) {
    .Call('skm_skm_mlp_cpp', PACKAGE = 'skm', x, k, s_must, max_it, max_at)
}

skm_mls_cpp <- function(x, k, g, s_must, max_it, max_at) {
    .Call('skm_skm_mls_cpp', PACKAGE = 'skm', x, k, g, s_must, max_it, max_at)
}

skmRpl_mlp_cpp <- function(x, k, s_must, max_it, max_at, skmRpl_GS = 100L) {
    .Call('skm_skmRpl_mlp_cpp', PACKAGE = 'skm', x, k, s_must, max_it, max_at, skmRpl_GS)
}

#' stratified_sampling: from v select k w.r.t stratify structure g.
#' TODO: implementing via template so v is flexible as vec or uvec.
#' @param v: candidate v.
#' @param k: selection k.
#' @param g: stratify structure g.
#' @return s: select from v length k stratified by g.
stratified_sampling <- function(v, k, g) {
    .Call('skm_stratified_sampling', PACKAGE = 'skm', v, k, g)
}

